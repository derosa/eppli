#summary Memoria del proyecto
#labels Phase-Deploy,Memoria

= Introducción =
Esta página contiene la memoria del proyecto, para ser formateada y recauchutada luego en el editor.

La memoria debe contener ~60 páginas, junto con una presentación de unas 20.

La primera entrega de la memoria debe tener un índice detallado y algunos capítulos introductorios.

= Índice =

 # Introducción.
  # Presentación del proyecto.
  # Introducción a la planificación de procesos.
  # El planificador de procesos de linux.
 # El proyecto _eppli_.
  # Requisitos y funcionalidades de _eppli_.
  # El _scheduler_ de linux aplicado a _eppli_.
 # Diseño de _eppli_.
  # Herramientas de construcción.
  # Estructuras de datos.
  # Subsistemas.
 # Implementación.
  # Núcleo de emulación.
  # Interfaz gráfica.
 # Bibliografía.
  # Libros.
  # Internet.

= Introducción = 

== Presentación del proyecto ==

A pesar de la gran cantidad de documentación existente sobre la teoría de planificadores de procesos en sistemas operativos, no existen apenas aplicaciones prácticas de estos principios más allá de su uso real en SS.OO.

La primera dificultad con que un estudiante se encuentra a la hora de encarar estos algoritmos es la falta de resultados prácticos: Ver cómo se evalúan procesos reales, saber por qué el planificador cambia de tarea, cómo se cambia la prioridad de los procesos, cómo afecta el que un proceso sea CPU intensivo o I/O intensivo, etc. Todo esto no es fácilmente mensurable en un S.O. en ejecución, por lo que se hace necesario un método que no solo sea más interactivo y parejo con la velocidad de proceso de la persona, sino que permita indagar en las interioridades del mismo y modificarlo para ver cómo afectan los cambios a los resultados.

La resolución de estos problemas es el objetivo de mi TFC, que consiste en la programación de un emulador del planificador de procesos del kernel linux. El nombre del proyecto es _EPPLI_ (*_Emulador del Planificador de Procesos de Linux_*), y puede seguirse desde http://code.google.com/p/eppli

== Introducción a la planificación de procesos ==

El principal cometido de un sistema operativo es gestionar los recursos de la máquina donde se ejecuta. Se gestiona la memoria, las peticiones de I/O, los dispositivos... y se gestionan procesos.

Un procesador solo puede ejecutar un proceso cada vez, por lo que la aparente ejecución simultánea de muchos procesos (conocida como multitarea), se trata en realidad de un "truco" conjunto del procesador y el SSOO. En realidad lo que ocurre es que el SSOO alterna la ejecución de los procesos de diferentes formas (según el algoritmo de planificación) dando a cada proceso un corto tiempo de CPU de forma que cree la ilusión de ejecución simultánea para el usuario. 

Esta gestión de procesos recibe el nombre de planificación de procesos y es llevada a cabo por el planificador de procesos (_process scheduler_). Esta parte del SSOO se encarga de decidir qué proceso debe ejecutarse en un momento determinado en función del entorno. Ésta tarea no es fácil, pues debe intentar cumplir con varios objetivos, a veces incongruentes entre sí:

 # El tiempo de CPU debe ser repartido de forma justa entre todos los procesos.
 # Los procesos interactivos deben seguir siéndolo.
 # A cada proceso debe permitírsele la ejecución durante un mínimo de tiempo.
 # Ningún proceso debe estar demasiado tiempo sin usar la CPU (_process starvation_)
 
Puede verse que, por ejemplo, los puntos 1 y 2 son opuestos. No es posible repartir de forma justa el tiempo de CPU entre todos los procesos si se favorecen los procesos interactivos. Cuando se favorece un tipo de procesos, inevitablemente otros procesos "sufren" las consecuencias.

De la misma forma, los puntos 3 y 4 también caen en la contradicción: Si cada proceso debe ejecutarse un mínimo periodo de tiempo, con suficiente número de procesos en ejecución no será posible impedir que un proceso esté demasiado tiempo sin CPU. Por ejemplo, si en un sistema tenemos 10 procesos en ejecución y se ejecutan cada uno de ellos durante 100ms. secuencialmente, habrá un proceso que no podrá usar la CPU hasta que transcurra 1 segundo.

Teniendo en cuenta lo anterior, un planificador de procesos debe tener claro a qué entorno está orientado, pues no es lo mismo un entorno de computación científica donde los procesos usarían la CPU durante horas continuamente si pudieran, que el equipo de un equipo de producción de video, donde los procesos necesitan capacidad de ejecución y reacción en tiempo real. Es necesario un compromiso entre los procesos interactivos y los que usan intensivamente la CPU.

Históricamente se han diseñado los planificadores de procesos siguiente esquemas simples, pero el cambio de las necesidades de los usuarios, normalmente orientados a aplicaciones más interactivas) han hecho necesaria la evolución de estos esquemas. Algunos de estos métodos simples son:

 * FIFO (_First In, First Out_): Consiste en despachar los procesos por orden de llegada y hasta que estos abandonen voluntariamente la CPU. Su uso es más obvio en los primeros sistemas por lotes, en los que no existía interactividad del usuario.
 * Por rotación (_Round Robin_): Los procesos se ejecutan durante un cuanto de tiempo determinado. Cuando este cuanto expira se pasa directamente al siguiente proceso de la lista, volviendo al primero cuando se termina con el último proceso.
 * Colas multinivel (_Multilevel queues_): Diversas colas administradas por _Round Robin_, cada una de una prioridad. Los procesos pueden pasar de una cola a otra, dependiendo de ciertos factores.
 * Planificador por lotería (_Lottery Scheduling_): Consiste en asignar a cada proceso un número de ticket. Cuando hay que seleccionar un proceso, el planificador selecciona un número al azar y ejecuta el proceso correspondiente.
 
Otro concepto necesario para comprender la extensión de la problemática asociada a la planificación de procesos es el de apropiación (_preemption_):
La apropiación consiste en arrebatar la CPU a un proceso en ejecución mientras aún no la ha cedido voluntariamente. Sistemas operativos monotarea y monousuario, como MS-DOS, carecen del concepto de apropiación, por lo que un proceso continuaba la ejecución hasta que terminaba o cedía voluntariamente la CPU (_cooperative multitasking_). Esto tiene la ventaja de ser un sistema fácil de desarrollar y mantener, pues simplemente se ejecuta la aplicación solicitada, pero implica que el sistema queda a merced del proceso en ejecución. Actualmente la mayoría de SSOO hacen uso de la apropiación, que hace posible retirar la CPU a un proceso cuando se determina que su cuota de tiempo ha finalizado. En el kernel linux es posible incluso apropiarse de la CPU mientras el proceso ejecuta código del kernel. Por ejemplo, puede quitarse la CPU a un proceso mientras está llamando a la función sys_read del sistema.

== El planificador de procesos de linux ==

El planificador de procesos de linux es una de las partes que más reformas sufre a lo largo de las diferentes versiones del núcleo. Empezando por la serie 2.4, en la que el planificador constaba de unas 1.400 líneas de código, hasta la serie 2.6, con más de 5.000 (2.6.11) u 11.000 (2.6.25-rc8). Esta evolución es la responsable de la calidad del planificador, que ha pasado de ser de una eficiencia linear (O(n), serie 2.4) a constante (O(1), serie 2.6).

La principal debilidad del planificador de la serie 2.4 es el algoritmo para determinar la cantidad de tiempo que un proceso podía ejecutarse, que se calculaba iterando sobre toda la lista de procesos. Además, el tiempo medio asignado a los procesos es de 210ms, que contrasta con la media de 100ms de la serie 2.6. Recordemos que con estas cantidades, un servidor con 100 procesos usando todo el tiempo asignado puede hacer esperar hasta 20 segundos al proceso de más baja prioridad del sistema, lo que no es admisible.

El objetivo del planificador en la serie 2.6 es mejorar los puntos débiles de la serie 2.4. Esto se consigue con el que se conoce como "The O(1) Scheduler", o planificador de tiempo constante, que tiene siempre el mismo coste de ejecución, independientemente del número de procesos del sistema.

HABLAR TOCHO 2.6.11

A partir de la versión 2.6.23, linux usa un planificador conocido como CFS (_Completely Fair Scheduler_), que en lugar de colas de ejecución (_run queues_), usa una estructura de datos llamada "árbol Rojo-Negro" (_Red-Black Tree_).

